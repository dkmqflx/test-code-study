## ProductCard(단위) vs ProductList(통ㅇ합)

- 단위 테스트, 통합 테스트 각각 작성할 수 있으나

- 테스트 작성 실행의 효츌성, 코드의 유지보수 측면에서

- 통합 테스트를 작성해서 한번에 검증하는 것이 훨씬 효율적

<br/>

## 4.1. 통합 테스트란 무엇일까?

### Q.

- web api인 IntersectionObserver을 활용한 훅이 있는데요, 훅은 독립적으로 동작되기 때문에 단위 테스트 대상이라고 말씀하셨는데,

- 궁금한점은

1. web api를 활용한 훅은 단위테스트 대상일까요? 테스트 환경이 다르고 web api는 이미 검증된 api이기 때문에 단위테스트 대상에서 제외 했거든요

2. 만약 단위 테스트 대상이라면 web api를 모킹해서 훅을 통해 반환한 값들을 확인 하면될까요?

3. 단위테스트 대상이 아니라면 통합테스트에서 해당 훅을 제대로 호출해서 사용하는지만 확인하면 될까요?

### A.

- 코드를 보면 의견이 조금 달라질 수 있을 것 같지만, 우선 제공해주신 내용을 기준으로 답변 드리겠습니다.

- 개인적으로는 이미 구현이 되어있는 Web API는 테스트를 할 필요가 없습니다. 이런 테스트를 통해 기대하는 동작을 확인해 보기 어려울 수 있고, 의미 있는 테스트라고 보기는 어려울 것 같습니다. 이런 동작들은 저희 테스트 환경에서 JSDOM에 구현이 되어 있는데 실제 브라우저의 동작과 다른 부분이 있기 때문에 잘 동작한다 한들 실제 브라우저에서 잘 동작되는 것과는 의미가 다릅니다. (https://ui.toast.com/posts/ko_20220624)

- 그것과 별개로 해당 동작은 브라우저에서 관할하는 부분이며 문제가 발생하고 예상대로 동작하지 않는 부분을 가정하고 검증하는 것이 필요가 없을 것 같습니다. 마치 외부 라이브러리 처럼 문제가 발생해도 저희들이 관여할 수 없는 영역은 테스트의 영역에서 분리를 하는 것이 좋습니다.

- 다만, 말씀해주신것처럼 조건에 따라 Web API가 호출되는 것처럼 해당 코드를 호출된 이후의 동작은 정상적일것이라는 '가정하에' 해당 동작을 스파이로 검증한다면, 그정도는 충분히 검증할 수 있는 부분이라고 볼 수 있을 것 같습니다. (다만, 일부분에 대한 검증이기 때문에 여전히 아쉽기는 할 것 같습니다.)

- 추가로 저희는 테스트하는 환경에서 JSDOM을 활용하는데요. JSDOM에서 해당 동작을 지원하는지 확인해보면 좋을 것 같습니다. (https://github.com/jsdom/jsdom/issues/2032)

## 4.4. 통합 테스트 작성하기 - 상태 관리 모킹

### Q. 만약 상호작용하는 컴포넌트에서 각각 상태를 관리하고 있다면

- 효율적인 테스트를 위해 상태 관리는 상위 컴포넌트에 응집해서 관리하는것이 좋다고 하셨는데

- 컴포넌트가 캡슐화 되어있으면 서로 상호 작용하는 컴포넌트지만 동일한 상태 조회를 각 컴포넌트에서 독립적으로 하게되는 경우도 있을거 같습니다.

- 이런 경우는 테스트에 용이하도록 구현 코드를 수정해야하는지, 아니면 번거롭더라도 그대로 테스트 코드를 작성해야 하는지 궁금합니다.

- 애초에 컴포넌트 설계를 잘못했다고 판단해야 할까요?

### A.

- 테스트 코드와 설계의 관계에 대해 문의주신 걸로 이해가 되는대요.

- 상황에 따라 달라질 것 같습니다.

- 동일한 상태 조회를 하는 컴포넌트여도, 도메인 별로 컴포넌트화가 잘 되어 있다면 구조상 테스트 코드를 작성할 때도 큰 이슈는 없을 것 같습니다.

- 하지만 특정 부모 컴포넌트 하위의 여러 컴포넌트에서 동일한 상태를 조회하고 수정하거나, 해당 도메인과 관련성이 적은 컴포넌트에서 계속 상태를 조회하고 변경한다면, 테스트 코드의 단위를 특정하기 모호해집니다. 이런 경우는 테스트 코드 유무를 떠나서 설계상 수정이 필요하다고 할 수 있습니다.

- 컴포넌트 개발에서는 도메인이나 컨텍스트에 맞게 계층화를 잘 하는 것이 중요한대요. 이 계층화를 통해 컴포넌트의 도메인을 나눈 후에는 상태에 대한 관리를 여기저기 너무 산재되지 않도록 중간 중간 상태 끌어올리기(state lift up)을 사용하여 일관된 구조를 만들고 테스트를 작성하는 것이 좋습니다.(강의의 통합 테스트 부분에서도 나오는 내용입니다!)

- 이런식으로 구조를 작성하면 상태를 가진 컴포넌트를 기준으로 통합 테스트를 작성하면 되고, 하위의 컴포넌트는 스토리북으로 UI가 올바르게 렌더링되는지 확인하는 형태로 명확하게 책임을 나누어 검증할 수 있습니다.

- 강의 서두에 나오듯이 테스트 코드를 작성하는 이유 중 하나가 이런 설계에 대한 다양한 고민과 시각을 가지도록 해주는 것인대요.

- 만약 컴포넌트에 대한 테스트 범주가 모호하고, 상태에 대한 검증까지 같이 하기 너무 비대해진다면, 말씀하신대로 설계에 대한 고민을 해봐야 하는 시점이라 생각됩니다.

<br/>

### Q.

- '특정 아이템의 수량이 변경되었을 때 값이 재계산되어 올바르게 업데이트 된다' 테스트 실행시 변경점이 있는 price를 '$4,045.00'과 같이 직접 입력하셨는데요.

- 이 부분을 formatPrice(809\*4) 이런식으로 하면 formatPrice에 변경점이 생겼을 때도 테스트가 깨지지 않고 검증할 수 있고, 작성하기 더 쉬워보인다고 생각하는데요. 혹시 그렇게 하지 않은 이유가 따로 있을까요 ? (독립성을 보장한다던가..)

- 아래의 '특정 아이템의 수량이 1000개로 변경될 경우 "최대 999개 까지 가능합니다!"라고 경고 문구가 노출된다' 테스트의 cartValidationMessages.MAX_INPUT_VALUE 값도 마찬가지입니다 !!

### A.

- 개인적으로는 명확하게 검증하고자 하는 값은 스태틱하게 입력하는 편인데요.

- 이렇게 작성하게 될 경우 명확한 결과값을 예상할 수 있고, 테스트 코드의 가독성이 올라가는 장점이 있습니다.

- 추가로, formatPrice를 언급해 주셨는데요!

- 해당 함수의 포맷팅 양식이 변경됨에 따라 깨지지 않고 검증을 할 수 있겠지만, 여기서 만약 formatPrice의 동작을 잘못 구현했다면 테스트 코드에서는 결과값이 잘못되었는지 검증할 수 없습니다. 늘 통과하겠죠.

- formatPrice에 대한 독립적인 테스트 코드가 없다면 더더욱 위험한 상황일수도 있겠네요.

- 결국 이 테스트 코드를 운영하는 비용을 줄이는 것도 좋지만, 이 테스트가 검증하는 함수와 범위가 무엇인지 그리고 그 범위의 코드들이 잘못된 것을 어떻게 하면 민감하게 알아차릴 수 있는지 고민해보면 될 것 같습니다.

- 상수에 있어서는 그대로 사용할 수 있는 충분한 범위라고 생각하는데, 테스트 코드가 스펙이라고 가정하고 스펙에 맞게 최댓값을 제대로 입력했는지 검증하고자 한다면 스태틱한 값으로 넣는 게 저는 좋을 것 같습니다.

<br/>

### Q. 4.4 통합테스트에서 정적 데이터로 테스트하는 대신 role 값을 미리 설정해 직접 돔에 접근하는 방식은 어떤가요?

```jsx
// answer 브랜치 코드

it('특정 아이템의 수량이 변경되었을 때 값이 재계산되어 올바르게 업데이트 된다', async () => {
  const { user } = await render(<ProductInfoTable />);

  const [firstItem] = screen.getAllByRole('row');
  const input = within(firstItem).getByRole('textbox');
  await user.clear(input);
  await user.type(input, '5'); // 2427 + 809 _ 2 = 4045

  expect(screen.getByText('$4,045.00')).toBeInTheDocument();
});
```

- 궁금한 점은 현재 제공해주신 정답 코드에서는모킹 데이터의 결과 포맷을 알기 때문에 '$4,045.00' 이라는 텍스트 값이 dom에 마운트 되어야 테스트를 통과 시키는 방식인데요

```jsx
it('특정 아이템의 수량이 변경되었을 때 값이 재계산되어 올바르게 업데이트 된다', async () => {
  const { user } = await render(<ProductInfoTable />);

  const [firstItem] = screen.getAllByRole('row');
  const input = within(firstItem).getByRole('textbox'); // role은 price를 담는 div에 미리 추가했다고 가정
  const price = Number(within(firstItem).getByRole('price').textContent);
  const value = 5;

  await user.clear(input);
  await user.type(input, value.toString());

  const pricedResult = within(firstItem).getByRole('price').textContent; // 2427 + 809 \_ 2 = 4045
  expect(priceResult.includes((value\*price).toLocaleString())).toBe(true);
});

```

- 제가 작성한 방식은엘리먼트마다 role을 미리 지정해 둔 다음에테스트할 때마다 element들의 값에 접근해서 테스트를 진행하는 방식입니다.

- 제가 생각했을 때에는 이 방식을 사용하면 element마다 role을 직접 설정해주어 element의 용도를 파악하기 더 쉽고 getAllBy... 메소드로 가져온 요소들에 대해 순회하여 테스트할 때 테스트 결과 값을 동적으로 생성하기 때문에 더 유연하지 않을까 라는 생각이 들었습니다. 궁금한 점은 제가 작성한 방식을 현업에서도 사용하는지잘 사용되지 않는 방식이라면 어떤 이유에서 잘 사용되지 않는지가 궁금합니다

### A.

- DOM에 직접 role을 부여하여 테스트 하면 동적인 결과값을 검증하기 더 편리하지 않은지 문의 주신걸로 이해되는대요.

- 저희가 role을 강제로 부여하지 않고 예제처럼 테스트를 작성한 이유는 크게 두가지가 있는대요.

- 우선 통합 테스트에서는 모킹 데이터 기반으로 테스트를 실행하기 때문에 특정 컴포넌트를 렌더링했을때 모킹 데이터 기준으로 원하는 기대값을 알고 검증할 수 있습니다. 이때 $4,045.00처럼 구체적인 기대값을 쓰는 이유는 특정 DOM 구조에 의존하지 않고 정확히 연산된 기대값이 무엇인지 확인하기 위함입니다. Number(within(firstItem).getByRole('price').textContent) 로 작성하면 동적인 계산 결과를 대응할 수 있지만, price란 role을 가진 요소에 계산 결과를 의존하게 됩니다. 해당 요소가 사라지거나 변경되면 테스트가 깨질 수 있으며, 계산 결과는 DOM의 특정 값에 의존하는게 아니라 실제 데이터에 의존하여 계산되는 것이기 때문에 모킹 데이터 기준으로 연산한 $4,045.00 값이 있는지를 검증하였습니다.

- 두번째로 role이란 속성은 W3C에서 웹 접근성을 위해 특정 요소마다 부여한 스펙인대요. 특별한 상황이 아니면 특정 요소의 role을 강제로 부여하는 것은 웹의 시맨틱 정의에 어긋날 수 있습니다. 이로 인해 스크린 리더나 탭키의 동작, 웹 크롤러가 HTML을 수집할 때도 영항을 줄 수 있는대요. 이런 이슈때문에 별도의 role을 설정해서 검증하지 않았고, 만약 특정 요소 대상으로 testing library의 쿼리를 사용하고 싶다면 testid를 사용하는 것을 공식적으로 권장하고 있습니다.
  위의 2가지 이유로 role을 직접 부여하지 않고 테스트를 작성하였습니다.

### Q.

- 테스트는 한 가지 기능이 잘 동작하는지만 보면 되기 때문에 데이터에 의존적인 동적인 방법 보다는

- 정적인 데이터로 정확하게 동작하는지 확인하는게 더 본래의 목적에 맞다고 이해했습니다.

- 제가 이해한게 맞게 이해한 걸까요?

### A.

- 한가지 기능을 검증한다는 것은 동적인 데이터를 사용해도 정적인 데이터를 사용해도 데이터만 달라질뿐 동일한대요.

- 다만, A input을 입력했을때 기대한 B output이 나오는지 명확하게 검증하기 위해 정적인 데이터 셋을 사용했습니다. 이렇게 정적인 데이터를 사용하면 계산식 자체에 문제가 있는 경우까지 테스트를 통해 인지하고 검증할 수 있어 좀 더 높은 안정성을 보장할 수 있습니다.

- 아래는 예제와는 조금 다르지만.. calculateValue()처럼 계산 과정이 별도 함수로 추출되어 있는 경우 calculateValue()함수를 그대로 사용하여 컴포넌트에 렌더링되는 기대값을 검증해버리면 calculateValue()함수의 계산식 자체에 문제가 있을 경우는 검증하지 못합니다.

```js
function calculateValue(value) {
  // ...
}

// calculateValue() 함수의 로직이 잘못되었을 경우 검증할 수 없다.
expect(result).toBe(calculateValue(value));

expect(result).toBe('$3,000');
```

- 개인적으로 이러한 휴먼 에러를 조금이나마 방지하고자 이미 명확하게 만들어진 정적인 데이터로 테스트를 작성하고 있습니다. 예제에서도 이런 의도를 갖고 명확한 데이터로 검증하도록 테스트를 작성하였습니다!

<br/>

## 5.1. 통합 테스트 작성하기 - ProductFilter

### Q.

- 최소 최대 가격을 수정할 때

- 최소 금액이 0보다 작을 때

- 최대 금액이 최소 금액보다 작을 때

- 위 같은 조건을 처리할 때 관련 질문입니다

1. describe 사용 여부

```js
// 1
describe('최소 최대 가격 확인 테스트', () => {
  it('최소 금액이 0보다 작을 때, 이렇게~ 처리', () => {});
  it('최대 금액이 최소 금액보다 작을 때, 이렇게~ 처리', () => {});
  it('최소 최대 가격을 수정하면 setMinPrice, setMaxPrice action이 호출된다', () => {});
});

// 2
it('최소 금액이 0보다 작을 때, 이렇게~ 처리', () => {});
it('최대 금액이 최소 금액보다 작을 때, 이렇게~ 처리', () => {});
it('최소 최대 가격을 수정하면 setMinPrice, setMaxPrice action이 호출된다', () => {});
```

2. 위 같은 조건 테스트를 작성 하는게 좋은지 아니면 아예 입력 처리를 해서 작성 안하는게 좋은지 확인 (0보다 작은수는 입력되지 않고, 최대 금액은 최소 금액보다 무조건 크게 작성하도록 처리 등)

### A.

- 첫번째 질문부터 답변드리면 우선 최소, 최대 금액에 대한 테스트를 그룹핑하려는 목적에서 describe를 사용해도 무방할 것 같습니다.

- 두번째 말씀하신 내용은 기획적인 내용과도 관련된 것으로 실무에서는 기획자와 기능을 어떻게 가져갈 것인지 조율한 후에 기능을 검증하면 될 것 같습니다. 예를 들어 기획 요구 사항에 금액 입력시 음수를 입력 불가란 내용이 있다면, 음수 입력이 불가능한지 검증하는 테스트가 있어야 할 것이고, 입력을 불가하게 막지 않고 금액을 올바르게 입력해주세요란 얼럿 문구를 보여주는 것이 요구 사항이라면 이 기획에 맞게 테스트를 진행해야 합니다.

- (저같은 경우 실무에서 대부분 양수 입력만 가능하게 제한하고, 최소 금액, 최대 금액이 잘못된 케이스는 얼럿으로 보여주는 형태로 구현을 하였습니다)

<br/>

### Q. 통합 테스트 작성 방식에 대해 궁금한 점이 있습니다

1. 테스트는 내부 구현에 의존하지 않고 사용자 입장에서 작성하는게 좋다고 이해했습니다.그런데 ProductFilter 컴포넌트의 통합테스트를 작성하시면서 "상품명을 수정하는 경우 setTitle 액션이 호출된다", "최소 가격 또는 최대 가격을 수정하면 setMinPrice와 setMaxPrice 액션이 호출된다" 와 같이 사용자가 값을 변경할 때 특정 액션 함수가 호출되는지를 검증하셨는데, 이건 내부 구현에 의존적인 테스트라고 볼 수 없을까요? 추후 Store 내부 구조가 바뀌거나 아예 Store를 사용하지 않는 식으로 구현 방법이 바뀌더라도 사용자 입장에선 달라지는게 없으니 테스트가 실패하지 않는게 좋은 테스트가 아닌지 궁금합니다.

2. api를 호출하는 커스텀 훅을 사용하는 컴포넌트를 테스트하실 때 msw를 이용해 해당 api의 응답을 모킹하셨는데, 커스텀 훅 자체를 모킹해서 훅이 반환하는 값을 원하는대로 지정하는 것도 가능할 것 같습니다. 이렇게 api 대신 훅을 모킹하여 테스트하는 것에 대해 어떻게 생각하시는지 궁금합니다.

### A.

1. 넵 맞습니다. 내부 구현에 대한 의존적인 테스트라고도 볼 수 있을 것 같습니다. 당시 코드를 작성했을 때 기억을 되살려보면.. ProductFilter에 대한 통합테스트이고 값이 변경되었을 때 실제 화면에서 적절하게 변경되었다라는 것을 인지할 수 있는 부분은 각 아이템들에 대한 값이 제대로 노출되는지 여부 정보만 검증할 수 있다고 생각했던것 같습니다. 추가로 필터로 지정된 값으로 더 외부에서 노출되는 아이템이 달라지기 때문에 영향을 미칠 수 있는 store set 함수를 테스트하지 않았나 라고 생각이 듭니다.

- 현재 테스트 구조상 E2E 테스트에서 실제 필터값의 결과를 테스트하고 있기 때문에 올바른 동작을 검증하고 있습니다. 그래서 Home에 대한 페이지의 통합테스트는 따로 작성되지 않았는데요. 만약 E2E테스트를 사용하지 않고 좀 더 통합테스트에서 해당 동작을 검증하고 싶다면 Home에 대한 통합테스트를 작성해서 실제 결과를 검증해보면 말씀해주신 사용자 관점의 테스트가 될 것 같습니다.!

2. 만약 훅 자체를 반환한다면 훅을 사용하는 컴포넌트 내에서 훅에 대한 검증이 사라지게 되는데요. API 응답만을 모킹하게 되면 해당 훅에 대한 동작은 함께 검증할 수 있기 때문에 두 테스트의 검증 범위가 달라지게 됩니다. 따라서, 테스트 목적에 맞게 판단해서 진행하면 될 것 같습니다.

<br/>

## 5.3. 통합 테스트의 한계 - 구매 페이지

### Q. TestPayment에 쿠폰 정보를 prop으로 전달하는 이유

- Payment테스트 코드 작성 부분에서 몇가지 궁금한점이 생겨 질문 드립니다.

1. 실제 Payment 컴포넌트에서는 useCouponList훅으로부터 selectedCoupon데이터를 받아와서 사용하는데 테스트 코드에서는 쿠폰 정보를 prop으로 전달하는 이유가 무엇인가요?

2. 실제 구현 동작을 보면 ShippingInformationForm에서 쿠폰을 선택하면 Payment 쿠폰란에 곧바로 반영되는데 이런 부분까지는 통합테스트에서 검증하지 않아도 되나요?

### A.

1. useCouponList에서 RHF를 사용하고 있기 때문에 간단한 래핑을 통해 구성했습니다. 만약 useCouponList에서 RHF의 결합을 끊고 외부에서 주입하는 형태로 구현이 된다면, 별도 컴포넌트 모킹은 필요없을 수 있습니다.

2. 현재는 할인 금액만 검증하고 있는데요! 선택한 쿠폰의 이름을 검증하는 것도 좋아 보입니다.
