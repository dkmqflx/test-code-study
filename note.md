## Arrange-Act-Assert 테스트 작성 패턴

### 1. Arrange

- 컴포넌드를 렌더링하는 코드와 같이 테스트를 위한 코드

### 2. Act

- 테스트할 동작을 재현하는 코드

- 컴포넌트를 클릭하거나 키를 입력하는 등

### 3. Assert

- 우리가 원하는 대로 결과가 나왔는지 검증하는 코드

<br/>

## 2.3 setup과 teardown

- 테스트가 시작 전 후에 다른 테스트에 영향을 미치지 않도록 초기화나 데이터 세팅을 다시하도록 한다

- [공식문서 - Setup and Teardown](https://vitest.dev/api/#setup-and-teardown)

  - setup: before-\*

  - teardown: after-\*

- setup과 teardown 함수를 전역적으로 선언할 수도 있지만, describe 안에 작성해서 해당 describe 안에서만 작동하도록 할 수 있다.

---

## 2.1. 단위 테스트란 무엇일까?

### Q.

- 타입스크립트를 쓰는 경우에 일반적으로 props나 리턴 값이 타입스크립트 type으로 명확하게 정의가 된다면 테스트를 생략해도 될 것 같다는 생각이 드는데요.

- 중요하고 비싼 비지니스 로직이거나 복잡한 코드라서 테스트를 붙여서 검증해야한다는 기본 전제는 빼고 생각했을 때요... 가르침 부탁드리겠습니다..

### A.

- 기본적으로 eslint나 타입스크립트와 같은 정적 분석 도구를 사용하면 함수의 인자나 리턴 값, 선언된 변수의 타입, 조건문 등 로직 작성 단계에서 발생할 수 있는 다양한 오류를 개발이나 리뷰 단계에서 방지할 수 있습니다. 실제로 이러한 도구의 등장으로 예전처럼 코드 상에서 타입 체크를 위한 방어 코드를 작성하는 일도 많이 사라지게 되었구요.

- 그렇기 때문에 말씀하신 것처럼 a() 함수를 호출하면 문자 타입의 데이터를 반환한다와 같은 type 체크 테스트는 작성하지 않는게 좋을 것 같습니다. a() 함수의 내부 로직 실행 결과로 인한 기대값은 당연히 테스트로 검증해야 하지만, type이나 문법상 잘못 동작할 여지가 있는 부분은 이미 정적 분석 도구를 통해 코드 작성 단계에서 충분히 사전 검증되었다고 할 수 있습니다.

말- 씀하신 내용과 비슷한 맥락으로 강의에서도 명확한 타입의 props만 받아 별도 복잡한 로직없이 UI만 렌더링(jsx 리턴)하는 presentational 컴포넌트에 대해서는 테스트 코드를 전혀 작성하지 않습니다.(이 내용은 강의 후반부 통합 테스트에서도 이야기합니다..!)

<br/>

### Q.

- 현재 하고 있는 프로젝트에 테스트 코드를 연습하고 있는데 상태 기반 검증은 보통 "custom hook"과 같이 비즈니스 로직에 하고, 행위 검증은 컴포넌트의 이벤트 처리와 같은 상황에 하고 있는데 이렇게 진행하는게 맞는 건지에 대해서 궁금해서 질문을 남기게 되었습니다!

- vitest에서는 stub과 mock과 같은 테스트 더블을 완벽하게 구별짓지 않는다고 생각하고 있는데 맞을까요?

- 추가적으로 공부를 해보았을 때 상태 기반 검증은 stub, fake 행위 기반 검증은 mock, spy로 하는 것이라고 나누었는데 이것이 맞는 내용인가요?

### A.

- 우선 말씀하신 것처럼 커스텀 훅의 경우 비즈니스 로직 자체에 대한 입력과 결과 특히 상태의 변화에 대해 테스트를 작성하는 것이라 할 수 있습니다. 그리고 컴포넌트 역시 사용자가 이벤트를 발생시켰을 때의 상태 변화를 검증하는 상태 기반 검증이라 할 수 있습니다.

- 일반 함수나 커스텀 훅과는 다르게 내부적으로 캡슐화되어 사용되는 React의 state가 검증 대상이 아닐 뿐, 이 상태가 DOM에 제대로 반영되는지 DOM의 상태 변화를 검증합니다. 즉, 컴포넌트 통합 테스트 역시 상태 기반의 검증이라 할 수 있습니다. 컴포넌트의 상태가 올바르게 DOM에 반영되는지 검증하고 있기 때문이죠. (컴포넌트의 상태 검증을 위한 테스트 코드 작성 형태가 이벤트를 통한 행동 기반인 것이지, 테스트 검증 자체는 결국 DOM 상태를 기준으로 하고 있습니다!)

- 다만, 강의 예제에서 일부 케이스 테스트는 말씀하신 행위 기반의 테스트로 작성되어 있습니다. 바로 리액트 라우터를 통한 네비게이션 검증이 대표적인 예시인대요. JSDOM 기반의 테스트 구동 환경은 실제 브라우저 환경이 아닙니다. 그렇기 때문에 제대로 url이 변경되는지 검증하기 어려우며, 그렇다고 외부 라이브러리인 리액트 라우터의 내부 구현에 따른 상태를 테스트에서 검증하게 되면 배보다 배꼽이 더 커지는 형태가 됩니다.

- 이렇게 내부 테스트에서 검증하기 힘든 외부 영역(라이브러리 또는 다른 외부 시스템)이 있을때는 spy나 mock을 사용해 행위 기반으로 검증합니다. 예제의 경우 링크 이동에 필요한 navigate함수가 호출되었는지 spy를 통해 행위 기반으로 검증하고 있습니다.

- spy나 mock을 사용한 테스트는 대부분 어떤 행위를 했는지 안했는지 검증하기 때문에 실제 상태가 올바르게 변경되었는지 정확성있게 검증하지는 못합니다. 그렇기 때문에 프런트엔드 테스트에서도 특별한 경우가 아니면 spy나 mock을 많이 사용하지는 않습니다.

- 강의에서는 msw를 사용한 API 응답 데이터를 갈아끼우는 행위도 모킹이라고 표현해서 헷갈리실 수 있는대요. 사실 이 부분도 응답 데이터를 우리가 원하는 데이터로 고정하여 상태를 검증하는 것이기 때문에 일종의 stub이라고 할 수 있습니다. (테스트더블에 대한 내용은 2부 강의 후반부에 좀 더 자세히 설명하니 참고 부탁드립니다 🙂)

- 내용이 길었는대요. 정리하자면 아래와 같습니다.

- 컴포넌트의 상태가 올바르게 DOM에 반영되는지 검증하고 있기 때문에 컴포넌트 통합(또는 단위) 테스트 역시 상태 기반의 검증이다. 대부분의 프런트엔드 테스트에서는 특별한 경우가 아니면 DOM 상태를 확인하는 상태 기반으로 검증한다.

- 외부 라이브러리 또는 시스템 내에서 제어할 수 없는 영역의 경우 spy나 mock을 사용하여 행위 기반으로 검증한다.

- msw를 사용한 API 응답 데이터를 갈아끼우는 것도 우리가 원하는 상태를 검증하기 위해 만든 stub이다.

<br/>

### Q.

- prop이나 state 값을 검증하지 않는다는 의미가 궁금합니다!

```js
const textField = screen.getByPlaceholderText('텍스트를 입력해 주세요.');
expect(textField).toHaveClass('my-class');
```

- 이부분에서 className이란 내부 props, state 값을 검증하는 게 아닌가 싶어서 질문을 드렸습니다.

- 물론, className에 따라 변경되는 DOM을 파악한다는 의미로도 해석이 될 수는 있을 것 같긴 하지만 더 정확한 문맥을 알고 싶어서 질문드렸습니다..!

### A.

- 컴포넌트의 prop이나 state값을 검증하지 않는다는 의미에 대해 문의주셨는대요.

- 프런트엔드 앱에서 사용자가 직접 보고 상호 작용을 하는 영역은 렌더링된 DOM 결과입니다. 이 DOM 구조는 내부적으로 리액트 컴포넌트를 통해 렌더링되며, 이때 state나 prop이 사용되는대요.

- 여기서 state나 prop은 리액트 컴포넌트 내부 메커니즘에 의해서만 사용되며, 이 값 자체가 외부로 노출되는 것이 아니라 상황에 맞게 DOM 결과를 변경하는데 사용됩니다.

- 이러한 맥락에서 컴포넌트의 className이란 prop을 직접 검증한다기보다는 className이란 prop이 텍스트 필드 DOM의 css class에 올바르게 적용되었는지 검증한다고 이해하시면 되는대요.

- 예제의 경우 별도의 조건없이 className을 prop을 바로 적용한 결과를 검증하다보니 의미가 조금 헷갈리실 수 있는대요.

- 만약 아래처럼 조금 복잡한 형태의 className 적용 로직이 있다면 inputClassName, hasError와 같은 prop값 자체를 테스트에 사용하는 것이 아니라 이 값들의 상태에 따라 렌더링된 DOM의 css class가 올바르게 변경되었는지 검증해야 합니다.

```jsx
<input
  type="text"
  classeName={
    // 조건에 따른 className 병합
    cn(inputClassName, { '!border-ORANGE pr-40': hasError })
  }
/>
```

- 즉, 컴포넌트의 단위, 통합 테스트는 항상 DOM 결과물을 기준으로 검증하는 것이 올바른 테스트라는 의미를 전달하려는게 목적이었구요. 예제에서 사용하는 react-testing-library 역시 이러한 철학을 그대로 계승하는 라이브러리입니다. (테스트하는 과정에서 컴포넌트의 state나 prop에 직접 접근하는 것도 어려우며, 권장되는 방법이 아닙니다 🙂)

- 결과적으로 testing-library의 조회 쿼리를 통해 리액트 컴포넌트가 원하는 DOM 결과로 렌더링되었는지 검증하는 것이 컴포넌트의 단위, 통합 테스트의 가장 중요한 포인트라 할 수 있습니다. 그리고 이러한 방식의 테스트는 사용자가 보고 상호 작용하는 DOM 구조 기반이기 때문에 실제 상황과 유사한 신뢰성 있는 테스트라고 할 수 있습니다.

### Q.

- 감사합니다~! 혹시 테스트에 대해 추가적인 학습을 병행하려고 하는데, 추천해주실만한 책이 있을까요?

### A.

- 개인적으로 추천드리는 책은 다음과 같은데요. 특정 책들은 자바스크립트가 아닌 다른 언어로 작성되어 있기도 하고, 책의 일부만 테스트와 관련이 있는 경우도 있는데요. 그럼에도 읽어보신다면 큰 도움이 되실 것이라 생각합니다.

- 단위 테스트 생산성과 품질을 위한 단위 테스트 원칙과 패턴

  - https://www.yes24.com/Product/Goods/104084175

- 테스트 주도 개발
  - https://www.yes24.com/Product/Goods/12246033
- 리팩터링 2판

  - https://www.yes24.com/Product/Goods/89649360

- 구글 엔지니어는 이렇게 일한다 구글러가 전하는 문화, 프로세스, 도구의 모든 것

  - https://www.yes24.com/Product/Goods/109182479
