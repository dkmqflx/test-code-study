<<<<<<< Updated upstream

## fireEvent

- 파이어 이벤트에서 클릭 이벤트를 발생시키는 경우 단순하게 해당 이벤트만 디스패치 한다

- 순수 자바스크립트 코드로 표현하면 마우스 이벤트 인스턴스를 만들어 디스패치 하는 것고 거의 유사

- 이 경우 클릭 이벤트에 대한 제어, 캡처링, 버블링만 가능할 뿐, 실제 사용자가 사용할 때 처럼 다양한 이벤트들이 시뮬레이션 되지 않는다

- # 유저 이벤트는 실제 시나리오가 고려되어 있다

## 3.1. 단위 테스트 대상 선정하기

### Q.

- 안녕하세요. 강의 내용 중 정확히 이해하지 못하고 있는 것이 있어서 질문 드립니다.

- 강의 중 로그인 버튼 같이 간단한 동작만 있는 컴포넌트는 그 자체를 테스트 하는 것이 아니라, 통합 테스트로 상태에 따른 동작을 검증하는 것이 더 효율적이고 정확한 테스트가 된다. 라고 하셨습니다.

- 또한 이런 컴포넌트는 스토리북과 같은 도구를 사용하여 스타일이나 레이아우싱 틀어지지 않는지 확인하는 것이 더 중요하다. 라고 말씀 하셨습니다.

- 이 뜻은 통합 테스트를 스토리북과 같은 도구와 함께 하라는 것이 아니라, 통합 테스트로 상태에 따른 동작을 검증하고, 그 안에 있는 각각의 컴포넌트들은 스토리북 안에서 스타일과 레이아웃이 틀어지지 않는지 확인하라는 것일까요?

- 아니면 스토리북을 통해 네비게이션 같은 컴포넌트를 만들고 그 단위로 통합 테스트를 하란 말씀이실까요??

### A.

- 우선 통합 테스트 강의에서 설명하듯이 통합 테스트의 단위는 비즈니스 로직이 응집되어 있는 컴포넌트가 되어야 하는대요. 이렇게 통합 테스트 대상이 되는 컴포넌트의 경우 UI를 렌더링하기 위한 여러 작은 컴포넌트로 결합되어 있습니다. 그리고 이 컴포넌트를 기준으로 비즈니스 로직에 대한 기능 검증을 실행합니다.

- 이와는 조금 다르게 스토리북은 기능 검증 보다는 개발 과정에서 UI가 올바르게 렌더링되었는지 확인하기 위한 도구입니다. 즉, 스토리북은 비즈니스 로직을 검증한다 보다는 UI를 확인한다 라고 할 수 있는대요. 그렇기 때문에 통합 테스트 단위와 스토리북 단위는 같을 수도 있지만 다른 경우가 더 많을 것 같습니다.

- 예를 들어 예매한 영화 티켓의 정보를 보여주는 컴포넌트가 있고 가정해보겠습니다.

- 이 컴포넌트에서는 API를 통해 티켓의 정보를 보여줘야 하며, 티켓 확인 버튼을 누르면 사용 완료 같은 문구를 보여줘야 할텐데요. 이런 다양한 비즈니스 요구 사항을 통합 테스트로 검증할 수 있습니다. 만약 예매한 영화 티켓의 정보를 보여주는 컴포넌트를 대상으로 스토리북을 작성한다면 API부터 상태 변경까지 모두 모킹하거나 별도의 조작을 통해 스토리를 작성해야 하는데요. 이렇게 되면 스토리 작성 작업에 대한 비용도 커지며, 원하는 스토리를 만들어 UI를 확인하는데에도 불필요하게 많은 시간이 소요됩니다.

- 결국 예매한 영화 티켓의 정보를 보여주는 컴포넌트도 예매 버튼, 티켓 정보를 보여주는 타이틀 등의 여러 컴포넌트들로 구성될텐데요. 이런 컴포넌트들은 UI를 보여주는게 전부이며 별도로 검증할 만한 로직들이 없습니다.

- prop으로 받은 정보를 렌더링하는 정도의 역할만 하기 때문에 단위 테스트를 작성하는 것이 크게 의미가 없고 오히려 스토리북으로 UI만 빠르게 확인하는 것이 좋습니다.

- 필요하다면 이런 presentational 컴포넌트들을 조합하여 스토리로 만들어 확인할 수도 있구요. (그렇기 때문에 컴포넌트 설계 시 통합 테스트 단위와 UI 확인 단위를 명확히 나누는 것도 굉장히 중요하다고 강의 후반부에 이야기합니다..!)

- 결과적으로 스토리북과 통합 테스트는 서로 확인하려는 목적이 다르기 때문에 단위가 다를 수 있습니다.

- 말씀하신 내용중에 통합 테스트를 스토리북과 같은 도구와 함께 하라는 것이 아니라, 통합 테스트로 상태에 따른 동작을 검증하고, 그 안에 있는 각각의 컴포넌트들은 스토리북 안에서 스타일과 레이아웃이 틀어지지 않는지 확인하라는 것이 강의의 목적에 좀 더 부합하는 방향으로 보입니다.

## 3.2. 모듈 모킹(Mocking)

### Q. mocking과 spy함수가 조금 헷갈립니다. 아래와 같이 정리하면 될까요?

- spy 함수 : 빈 함수인데, vitest에서 이 함수를 감지하고 있고 함수가 call 되었는지, 인자는 무엇이었는지 검증하는 가짜 함수.

- mocking : 종속성이 있는 라이브러리를 복사해두고, 그 중 사용해야 할 함수나 기능을 spy 함수로 대체하여 call 했는지 검사할 수 있는 프로세스.

- 그러면 mocking 자체는 spy 함수 없이 사용하는 것은 의미가 없다고 보면 될까요?

### A

- spy

  - 스텁과 유사하지만 구현된 객체가 어떠한 인자와 몇 번 호출되었는지 확인할 수 있습니다.

  - 주로, 어떠한 요소에 등록된 이벤트 리스너가 호출되었는지 확인할 때 spy를 사용할 수 있습니다.

  - spy를 사용한 테스트의 가장 큰 문제로는 특정 함수가 호출되었는지만 알려줄 뿐, 올바르게 동작하는지는 말해주지 못합니다.

  - 또한, 대상 시스템의 상세 구현방식을 활용한다는 점이 좋지 않습니다.

  - 그럼에도 적합한 경우가 있는데,

  - 실제 구현이나 가짜 객체를 이용할 수 없고, 상태 테스트가 불가능 한 경우 대비책으로 특정 함수가 호출된다는 확신으로 진행합니다.

  - 함수 호출 횟수나 순서가 달라지면 기대와 다르게 동작하는 경우 상태 테스트로는 검증이 힘들기 때문에 적합할 수 있습니다.

```js
it('클릭 이벤트 리스너가 등록되어야 한다.', () => {
  const spy = jest.fn();
  addClickEventListener(button, spy);
  button.click();

  expect(spy).toHaveBeenCalled();
});
```

- Mock

  - 실제 객체와 동일한 동작을 하도록 만들어진 모의 객체입니다.

  - 네트워크 통신에 필요한 axios 라이브러리를 대체하는 jest-mock-axios와 같은 라이브러리가 Mock의 대표적인 예시입니다.

  - mockAxios는 axios의 네트워크 통신에 필요한 요청과 응답을 모두 대체하며, 이 과정에서의 상황을 기록해두기 때문에 요청 url이나 파라미터를 모두 검증할 수 있습니다.

  - 실제 객체와 거의 동일하게 구현되었거나 대체하기 쉽게 추상화된 Mock 객체는 실제 객체로 대체하여 테스트를 실행할 때도 매우 유용하게 사용할 수 있습니다.

  - 다만 실제 모듈의 명세와 동일한 Mock객체를 구현하는 것은 큰 비용이 들며 이러한 모의 객체를 남용하는 것은 테스트 코드의 신뢰성을 떨어뜨릴 수 있습니다.

```js
import mockAxios from 'jest-mock-axios';

it('...', () => {
  let catchFn = jest.fn();
  let thenFn = jest.fn();
  addUser('user1').then(thenFn).catch(catchFn);

  expect(mockAxios.post).toHaveBeenCalledWith('/addUser/', { data: 'user1' });
  expect(thenFn).toHaveBeenCalled();
  expect(catchFn).not.toHaveBeenCalled();
});
```

### Q.

- 제가 부족하여 둘의 차이를 아주 명확하게 이해하기는 어려운데,

- spy 함수(vi.spyOn()) 같은 경우는, 기존 생성되어 있는 함수 자체를 감싸고 함수 자체를 call 할때 몇 번 call 했는지 인자는 어떤 것이 들어왔는지를 체크하는 함수이고

- mock 함수 (vi.fn()) 같은 경우 기존 구현체를 가짜로 구현하여 가짜 결과 값(실제와 비슷)을 내뱉어 검증하는 것으로 이해했습니다. 가짜 결과 값을 만들기 때문에 사이즈가 큰 모듈 같은 경우 사용하기 유용하고, 말씀 주신 jest-mock-axios 같은 mock 라이브러리는 axios 라이브러를 대체하기 위해 만들어진 라이브러리라고 이해했습니다.

- 2.4 React Testing Library와 컴포넌트 테스트 섹션에서

- const spy = vi.fn() 자체를 스파이 함수라고 지칭하셔서 mock 함수와 spy 함수가 헷갈리는 부분이 있었습니다.

- vitest 공식 홈페이지(https://vitest.dev/guide/mocking.html#functions) 모킹 함수는 spying, mocking 두 가지로 나누고 있다는 것을 발견했는데 요 둘을 구분하는 것과 무척 헷갈리는 부분이 있습니다

- 2.4 React Testing Library와 컴포넌트 테스트 섹션에서 사용하신 const spy = vi.fn() 함수 자체가 spy 역할을 하기 때문에 그렇게 사용하신 거라고 이해했습니다

### A.

- 충분히 헷갈리실만한 부분이 있다고 생각합니다. (사실 이를 명확하게 구분하는게 테스트를 잘 작성하는데 매우 크고 중요한 부분을 차지하지는 않는다고 개인적으로는 생각합니다.)

- 주신 문서에 나와있는 것처럼 vi.spyOn()을 사용하면 인수가 호출되었는지 확인할 수 있지만 구현을 바꿀 수 없으며, vi.fn()을 사용하면 구현을 변경할 수 있습니다.

- 테스트의 목적에 맞게 다양하게 각각 사용할 수 있으며, 내부적으로는 vi.fn()과 vi.spyOn()모두 동일한 메서드를 공유해 구현되어 있다고 되어있습니다.

- 아마 강의에서는 테스트의 해당 모킹 함수가 어떤 목적의 검증으로 쓰였는지에 따라 다르게 불렀던 것 같네요. (혼란을 충분히 줄 수 있는 지점이라 생각합니다. 🙇‍♂)

- 이해하기 쉽도록 vi.fn()은 딱 떨어지는 테스트 더블 타입에 종속되기는 어려우며 모킹 함수를 사용 목적에 따라 각각 사용할 수 있다 정도로 정리하는 건 어떨까요?

<br/>

### Q.

- 안녕하세요! 강의를 듣고 테스트 코드를 연습중에 질문이 있어서 글을 작성하게 되었습니다.

- 제가 테스트 코드를 작성하려는 프로젝트에서 공용 컴포넌트 중 Pagination 컴포넌트에 유닛 테스트 코드를 작성하려고 합니다.

- 제가 생각한 테스트 흐름은 실제 유저가 Pagination 컴포넌트의 화살표 버튼 클릭시 현재 페이지가 1이 증가하는 것처럼 테스트 코드를 구현하려고 했습니다.

- 하지만 Pagination 컴포넌트에는 setCurrentPage 함수를 주입 받아서 처리하기 때문에 유닛 테스트에서는 클릭으로 current page 값이 증가하는 것을 확인할 수는 없고 spy 함수를 통해 setCurrentPage가 실행되는 것까지만 확인하는게 맞는건가요??

### A.

- 우선 페이지네이션 컴포넌트 자체에서 말씀해주신대로 테스트를 작성할 수도 있겠지만, Spy 방식으로 테스트 할 경우 아래와 같은 문제가 있어 권장하지는 않습니다.

1. 특정 함수가 호출되었는지만 알려줄 뿐, 올바르게 동작하는지는 말해주지 못한다.

2. 대상 시스템의 상세 구현방식을 활용한다는 점

- 그럼에도 해당 테스트 방식이 적합한 사례는 다음과 같은데요.

1. 실제 구현이나 가짜 객체를 이용할 수 없고, 상태 테스트가 불가능 한 경우 대비책으로 특정 함수가 호출된다는 확신으로 진행한다.

2. 함수 호출 횟수나 순서가 달라지면 기대와 다르게 동작하는 경우 상태 테스트로는 검증이 힘들기 때문에 적합할 수 있다.

0 페이지네이션 컴포넌트가 위 사례에 해당하지 않는다면, 올바르게 렌더링 되는지 스토리북을 통해 시각적으로 검증하고 해당 페이지네이션 컴포넌트를 사용하는 부분에서 통합 테스트를 통해 올바르게 동작하는지 검증할 것 같습니다.

### Q.

- 말씀해주신 것 처럼 제가 생각한 페이지네이션 테스트 방식은 통합 테스트를 통해 전역 상태를 모킹해서 진행해야 할 것 같습니다. 또는 말씀해주신 것 처럼 스토리북을 이용해서 시각적으로 검증을 해야할 것 같습니다.

- 그렇다면 스토리북으로 단순 UI 렌더링을 통해 마크업을 확인할 뿐만 아니라 페이지가 제대로 이동하는지와 같은 기능 부분도 스토리 내에서 상태를 만들고 함수를 주입해서 테스트하는 경우도 많은가요?!

### A.

- 스토리북에서는 함수 기능에 대한 테스트를 할 수 있는 방법이 존재하지만 강의에서는 따로 소개를 해드리고 있지는 않습니다! 대신 시각적인 부분 검증하는데 사용을 권장하고 있는데요. 실제 페이지를 이동하는 부분은 E2E 테스트를 사용하면 실제 동작처럼 검증할 수 있으니 E2E를 사용하는 것이 좋을 것 같습니다.

- 2부 마지막 부분에서 각 테스트에 대한 검증 범위와 역할을 정리하고 있는데요. 해당 부분을 다시 한 번 들어보시면서 위 사례에 대해 고민해보시면 좋을 것 같습니다!

<br/>

### Q. navigate 관련 테스트에서 질문있습니다!

- 버튼을 눌렀을 때, navigate 하는 경우를 테스트할 때는 클릭 시 함수가 호출되었는지에 대한 테스트만 하면 되는 건가요??

- 혹시, 특정 경로로 잘 이동되었는지에 대한 테스트를 하는 방법이 있는지 여부와 해당 테스트가 존재한다면 통합테스트인건지 단위 테스트인건지 궁금합니다! 그리고, 그런 테스트가 존재한다면 어떻게 assert할 수 있는지도 알고 싶습니다!

### A.

- 결국 말씀해주신 기능에 있어서, 가장 실제 시나리오와 비슷한 검증은 E2E 테스트에서 가능할 것입니다. 클릭을 하면 실제 브라우저에서 경로가 변하기 때문에 url을 검증하면 제대로 이동이 되었는지 확인할 수 있거든요.

- 다만, 단위 통합 테스트 환경에서 navigate라는 함수를 호출했을때 navigate 함수가 제대로 동작할 것이라는 가정하에 어떤 경로로 호출되었는지를 검증하는 형태로 구현이 되어있을 건데요.

- 이렇게 확인할 경우 간편하다는 장점도 있지만, 단점 또한 존재합니다.

- https://www.inflearn.com/questions/1172186/mocking%EA%B3%BC-spy%ED%95%A8%EC%88%98%EA%B0%80-%ED%97%B7%EA%B0%88%EB%A6%BD%EB%8B%88%EB%8B%A4

- 이 질문에 간단하게 제가 정리를 해뒀는데요! 같이 읽어보시면 좋을 것 같습니다~

## 3.3. 리액트 훅 테스트(feat. act 함수)

### Q. act 함수와 renderHook 함수 내 rerender 차이

안녕하세요 궁금한게 있습니다. act 함수에 대해 이해했는데 act 함수없이 아래와 같이 해도 테스트가 통과되더라구요. 혹시 차이가 있을까요?

```js
it('훅의 toggleIsModalOpened()를 호출하면 isModalOpened 상태가 toggle된다.', () => {
  const { result, rerender } = renderHook(useConfirmModal);
  result.current.toggleIsModalOpened();
  rerender();
  expect(result.current.isModalOpened).toBe(true);
});
```

### A.

- 우선 강의의 내용을 먼저 정리해보면, act API의 경우 상호 작용(렌더링, 이펙트 등...)을 함께 그룹화하고 실행해 리렌더링과 업데이트가 실제 앱이 동작하는 것과 유사한 방식으로 동작합니다.

- 테스트에서 검증하고자 하는 내용은 toggleIsModalOpened() 메서드가 실행하면 훅 내의 state가 제대로 업데이트 되는지, 즉 위에서 언급한 것 처럼 상호 작용등이 한 번에 실행되어 원하는 상태로 업데이트 되는지를 검증하는 테스트이기 때문에 act API를 사용하는 것이 적합하다고 할 수 있습니다.

- rerender 함수 또한 강의에서 간단하게 언급드리긴 했지만, 원하는 인자와 함께 같은 컨테이너 내에서 새로 호출해 상태를 업데이트 하는 함수입니다. 주로 prop 변경에 따른 컴포넌트의 상태를 검증할 때 사용하곤 합니다. 이런 맥락에서, toggleIsModalOpened()를 호출한 뒤 rerender()를 명시적으로 호출한 뒤의 상태를 검증하는 흐름 자체가 테스트 내용에 적합한 동작의 흐름이라고 보기는 조금은 어색하게 느껴집니다.

- 관련해서 강의에서 언급하는 것처럼 테스트는 사용자의 실제 사용과 유사하게 테스트 할 수록 신뢰도가 올라간다고 말씀드리고 있는데요. 실제로 RTL 가이드 문서에서 rerender에 대한 설명(https://testing-library.com/docs/react-testing-library/api/#rerender)에는 (훅이 아닌 컴포넌트의 rerender에 해당하는 설명이지만, 동일한 맥락인 것 같습니다.) prop 업데이트를 올바르게 수행하는지를 검증하는 것을 권장하지, 구현 개념의 rerender를 사용해 prop에 따른 컴포넌트 세부 구현상황이 변경되는 것을 검증하는 것을 권장하지 않는다고 하고 있습니다. 현재 상황과 완벽하게 매칭되는 이야기는 아닐지라도 각 API의 목적에 맞게 테스트를 작성한 뒤 검증해야 테스트의 목적에 맞는 결과를 얻을 수 있을 것이라 생각합니다.

<br/>

### Q. 테스트 코드 파일 위치

- 다름이 아니라 테스트 코드 파일들의 작성 위치가 궁금한데요, 보니까 그냥 파일 바로 아래에 새로운 테스트 코드 파일이 있는 것 같은데 이게 보편적인 위치일까요?

- 따로 테스트 코드 폴더를 만들거나 하진 않는 건지 궁금해서 문의드립니다.

### A.

- 현재는 각 도메인별 컴포넌트 폴더 하위에 tests폴더를 만들어 단위, 통합 테스트 파일을 작성해두었는대요.

- 이렇게 작성한 이유는 크게 두가지가 있습니다.

- 먼저 컴포넌트와 동일한 뎁스로 테스트 폴더를 만들어두면 어떤 경로에 테스트 파일이 있는지 굉장히 쉽게 찾을 수 있고 IDE 트리에서도 컴포넌트와 테스트를 한 눈에 보며 이동할 수 있다는 장점이 있습니다. 그리고 두번째로 도메인별로 컴포넌트, 테스트, 스토리가 모두 응집되어 도메인에 대한 전반적인 로직 파악이 쉽기 때문에 이런 형태로 작성해두었습니다..!

- 개발 조직마다 선호하는 디렉토리 구조가 다를거라 컴포넌트와 완전 별도로 테스트 폴더를 만들어 관리하는 곳도 있을텐데요. 저희는 앞서 말한 장점때문에 별도로 분리하기 보다는 컴포넌트와 테스트를 응집한 구조를 선택하였습니다.

<br/>

### Q. 안녕하세요. 훅 테스트 질문이 있습니다!

- 예제에서 말씀해주신것처럼, result.current.setState() 를 호출해서 act() 를 통해 업데이트 된 상태를 검증하는 방법을 말씀해주셨는데요.

- 훅 내부 이펙트에서 상태를 업데이트하는 로직을 검증하려면 어떤 식으로 검증해야할까요?

```js
export const useDarkMode = (defaultTheme = THEME["LIGHT"]) => {
  const [theme, setTheme] = useState(defaultTheme);

  const changeTheme = (type: keyof typeof THEME) => {
    setTheme(THEME[type]);
  };

  useLayoutEffect(() => {
    const mediaQueryList = window.matchMedia("(prefers-color-scheme: dark)");

    const changeListener = ({ matches }: MediaQueryListEvent) => {
      setTheme(THEME[matches ? "DARK" : "LIGHT"]);
    };

    mediaQueryList.addEventListener("change", changeListener);

    return () => {
      mediaQueryList.removeEventListener("change", changeListener);
    };
  }, []);

  return {
    theme,
    changeTheme,
  };
};

```

- 위 useDarkMode() 훅 내부 useLayoutEffect() 에서 window.matchMedia 의 change 이벤트를 감지하면, setTheme() 하도록 설계되어 있는데요.

- window.matchMedia 함수의 matches 결과를 true 로 모킹하고, window.matchMedia.dispatchEvent('change') 를 일으켜 검증을 시도해보았는데요. 생각처럼 검증이 되지 않는 것 같습니다.ㅠ

- 혹시 이렇게 검증을 시도하는 것이 맞는지. 검증하는게 맞는지. 여쭤봐도 될까요? 감사합니다.

### A.

- 우선 보통 effect내에서 상태를 직접 변경하는 경우(effect 내에서 setTheme 직접 호출)에는 별도 작업없이 result.current.theme만 체크해도 변경된 상태값을 기준으로 검증할 수 있는대요.

- 하지만 말씀하신 코드에서는 effect 함수 내에서 mediaQueryList의 change 이벤트 등록 리스너만 실행됩니다. 그리고 이후에 change 이벤트가 발생했을때만 theme의 상태가 변경되도록 작성되어 있습니다.

- 이런 경우 원하는 matches 값 기준으로 이벤트 리스너를 등록하고 실행시켜야 하기 때문에 아래 정도로 window.matchMedia의 구현 자체에 모킹이 필요합니다.

```js
const mockMatchMedia = matches => {
  let targetListener;
  // 이벤트 등록 핸들러 스텁
  const stubAddEventListener = (eventName, listener) => {
    targetListener = () => listener({ matches });
  };

  // 이벤트 제거 핸들러 스텁
  const stubRemoveEventListener = () => {
    targetListener = null;
  };

  Object.defineProperty(window, 'matchMedia', {
    writable: true,
    value: vi.fn().mockImplementation(query => ({
      matches,
      media: query,
      onchange: null,
      addListener: vi.fn(), // deprecated
      removeListener: vi.fn(), // deprecated
      addEventListener: stubAddEventListener,
      removeEventListener: stubRemoveEventListener,
      dispatchEvent: vi.fn(),
    })),
  });
  // 이벤트 핸들러 강제 실행을 위한 dispatchEvent
  return { dispatchEvent: () => targetListener() };
};

// window.matchMedia에 대한 구현을 이전 설정으로 되돌린다.
afterEach(() => {
  Object.defineProperty(window, 'matchMedia', {
    writable: true,
    value: vi.fn().mockImplementation(query => ({
      matches: false,
      media: query,
      onchange: null,
      addListener: vi.fn(), // deprecated
      removeListener: vi.fn(), // deprecated
      addEventListener: vi.fn(),
      removeEventListener: vi.fn(),
      dispatchEvent: vi.fn(),
    })),
  });
});

it('theme가 dark 가 된다.', () => {
  const { dispatchEvent } = mockMatchMedia(true);
  const { result } = renderHook(() => useDarkMode());

  act(() => {
    dispatchEvent();
  });

  expect(result.current.theme).toBe('dark');
});
```

- 위 코드처럼 window.matchMedia 함수의 메커니즘에 필요한 이벤트 관련 API들을 모두모킹해야 비로소 원하는 시나리오대로 테스트를 작성할 수 있습니다. (node.js 환경에서는 미디어 쿼리를 전혀 지원하지 않기 때문에 이렇게 원하는 시나리오를 검증할 수 있는 별도 구현체를 만들어야만 확인이 가능합니다.)

- 개인적으로 단위 테스트에서 이렇게 미디어 쿼리와 관련된 모듈 모킹을 통해 테스트하기보다는.. 스토리북내에서 실제 브라우저의 미디어 쿼리와 연동하여 useDarkMode의 theme 상태가 제대로 반영되는지 확인하는 것이 더 정확하고 깔끔한 방법일 것 같습니다..!
  > > > > > > > Stashed changes
